/*
 * Teensy 4.0 - micro-ROS Motor Controller with Automatic Reconnection
 * Subscribes to direction commands and controls DC motors
 * Automatically reconnects to micro-ROS agent without physical reset
 */

#include <micro_ros_arduino.h>
#include <stdio.h>
#include <rcl/rcl.h>
#include <rcl/error_handling.h>
#include <rclc/rclc.h>
#include <rclc/executor.h>
#include <rmw_microros/rmw_microros.h>
#include <std_msgs/msg/int32.h>

// --- DEFINES ---
#define LED_PIN 13

// Macro to execute a block of code every N milliseconds
#define EXECUTE_EVERY_N_MS(MS, X)  do { \
  static volatile int64_t init = -1; \
  if (init == -1) { init = uxr_millis();} \
  if (uxr_millis() - init > MS) { X; init = uxr_millis();} \
} while (0)

// Check macro that returns false on error
#define RCCHECK(fn) { rcl_ret_t temp_rc = fn; if((temp_rc != RCL_RET_OK)){return false;}}

// --- MOTOR DRIVER PINS ---
// Adjust these based on your motor driver (L298N, TB6612, etc.)
#define MOTOR_LEFT_PWM 3    // Left motor speed (PWM pin)
#define MOTOR_LEFT_IN1 4    // Left motor direction
#define MOTOR_LEFT_IN2 5    // Left motor direction

#define MOTOR_RIGHT_PWM 6   // Right motor speed (PWM pin)
#define MOTOR_RIGHT_IN1 7   // Right motor direction
#define MOTOR_RIGHT_IN2 8   // Right motor direction

// Motor speeds (0-255)
#define SPEED_FORWARD 180
#define SPEED_TURN 150
#define SPEED_STOP 0

// --- GLOBAL VARIABLES ---

// Micro-ROS Entities
rcl_subscription_t subscriber;
std_msgs__msg__Int32 msg;
rclc_executor_t executor;
rclc_support_t support;
rcl_allocator_t allocator;
rcl_node_t node;

// Connection State Machine
enum states {
  WAITING_AGENT,
  AGENT_AVAILABLE,
  AGENT_CONNECTED,
  AGENT_DISCONNECTED
} state;


// --- MOTOR CONTROL FUNCTIONS ---

void moveForward() {
  // Left motor forward
  digitalWrite(MOTOR_LEFT_IN1, HIGH);
  digitalWrite(MOTOR_LEFT_IN2, LOW);
  analogWrite(MOTOR_LEFT_PWM, SPEED_FORWARD);
  
  // Right motor forward
  digitalWrite(MOTOR_RIGHT_IN1, HIGH);
  digitalWrite(MOTOR_RIGHT_IN2, LOW);
  analogWrite(MOTOR_RIGHT_PWM, SPEED_FORWARD);
}

void turnRight() {
  // Left motor forward (faster)
  digitalWrite(MOTOR_LEFT_IN1, HIGH);
  digitalWrite(MOTOR_LEFT_IN2, LOW);
  analogWrite(MOTOR_LEFT_PWM, SPEED_TURN);
  
  // Right motor backward or slow
  digitalWrite(MOTOR_RIGHT_IN1, LOW);
  digitalWrite(MOTOR_RIGHT_IN2, HIGH);
  analogWrite(MOTOR_RIGHT_PWM, SPEED_TURN);
}

void turnLeft() {
  // Left motor backward or slow
  digitalWrite(MOTOR_LEFT_IN1, LOW);
  digitalWrite(MOTOR_LEFT_IN2, HIGH);
  analogWrite(MOTOR_LEFT_PWM, SPEED_TURN);
  
  // Right motor forward (faster)
  digitalWrite(MOTOR_RIGHT_IN1, HIGH);
  digitalWrite(MOTOR_RIGHT_IN2, LOW);
  analogWrite(MOTOR_RIGHT_PWM, SPEED_TURN);
}

void stopMotors() {
  digitalWrite(MOTOR_LEFT_IN1, LOW);
  digitalWrite(MOTOR_LEFT_IN2, LOW);
  analogWrite(MOTOR_LEFT_PWM, 0);
  
  digitalWrite(MOTOR_RIGHT_IN1, LOW);
  digitalWrite(MOTOR_RIGHT_IN2, LOW);
  analogWrite(MOTOR_RIGHT_PWM, 0);
}

// Callback function when a message is received
void subscription_callback(const void * msgin)
{  
  const std_msgs__msg__Int32 * msg = (const std_msgs__msg__Int32 *)msgin;
  
  switch(msg->data) {
    case 0:
      stopMotors();
      break;
    case 1:
      moveForward();
      break;
    case 2:
      turnRight();
      break;
    case 3:
      turnLeft();
      break;
    default:
      stopMotors();
      break;
  }
}


// --- MICRO-ROS MANAGEMENT FUNCTIONS ---

bool create_entities()
{
  allocator = rcl_get_default_allocator();

  // Initialize options
  RCCHECK(rclc_support_init(&support, 0, NULL, &allocator));

  // Create node
  RCCHECK(rclc_node_init_default(&node, "micro_ros_motor_controller", "", &support));

  // Create subscriber
  // Subscribe to the same topic as your wall_follower.py publishes to
  RCCHECK(rclc_subscription_init_default(
    &subscriber,
    &node,
    ROSIDL_GET_MSG_TYPE_SUPPORT(std_msgs, msg, Int32),
    "micro_ros_algorri_subscriber"));

  // Create executor
  RCCHECK(rclc_executor_init(&executor, &support.context, 1, &allocator));
  RCCHECK(rclc_executor_add_subscription(&executor, &subscriber, &msg, &subscription_callback, ON_NEW_DATA));

  return true;
}

void destroy_entities()
{
  rmw_context_t * rmw_context = rcl_context_get_rmw_context(&support.context);
  (void) rmw_uros_set_context_entity_destroy_session_timeout(rmw_context, 0);

  rcl_subscription_fini(&subscriber, &node);
  rcl_node_fini(&node);
  rclc_executor_fini(&executor);
  rclc_support_fini(&support);
}


// --- SETUP & LOOP ---

void setup() {
  set_microros_transports(); // Standard serial transport setup
  
  pinMode(LED_PIN, OUTPUT);
  
  // Initialize motor pins
  pinMode(MOTOR_LEFT_PWM, OUTPUT);
  pinMode(MOTOR_LEFT_IN1, OUTPUT);
  pinMode(MOTOR_LEFT_IN2, OUTPUT);
  pinMode(MOTOR_RIGHT_PWM, OUTPUT);
  pinMode(MOTOR_RIGHT_IN1, OUTPUT);
  pinMode(MOTOR_RIGHT_IN2, OUTPUT);
  
  // Stop motors initially
  stopMotors();
  
  // Start in waiting state
  state = WAITING_AGENT;
}

void loop() {
  // State Machine for Connection Handling
  switch (state) {
    case WAITING_AGENT:
      // Try to ping the agent every 500ms
      EXECUTE_EVERY_N_MS(500, state = (RMW_RET_OK == rmw_uros_ping_agent(100, 1)) ? AGENT_AVAILABLE : WAITING_AGENT;);
      break;

    case AGENT_AVAILABLE:
      // Agent found, try to create ROS entities
      state = (true == create_entities()) ? AGENT_CONNECTED : WAITING_AGENT;
      if (state == WAITING_AGENT) {
        destroy_entities(); // Clean up if creation failed
      };
      break;

    case AGENT_CONNECTED:
      // Check connection every 200ms
      EXECUTE_EVERY_N_MS(200, state = (RMW_RET_OK == rmw_uros_ping_agent(100, 1)) ? AGENT_CONNECTED : AGENT_DISCONNECTED;);
      
      if (state == AGENT_CONNECTED) {
        // If connected, handle ROS callbacks (this runs the motor control logic)
        rclc_executor_spin_some(&executor, RCL_MS_TO_NS(100));
      }
      break;

    case AGENT_DISCONNECTED:
      // Connection lost, stop motors for safety, clean up memory and restart waiting
      stopMotors();
      destroy_entities();
      state = WAITING_AGENT;
      break;
      
    default:
      break;
  }

  // Visual feedback: LED on when connected
  if (state == AGENT_CONNECTED) {
    digitalWrite(LED_PIN, HIGH);
  } else {
    digitalWrite(LED_PIN, LOW);
  }
}