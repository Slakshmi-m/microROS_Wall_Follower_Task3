import rclpy
from rclpy.node import Node
from std_msgs.msg import Int32
import serial

class wall_follower_node(Node):
    def __init__(self):
        super().__init__('wall_follower_node')
        self.publisher_ = self.create_publisher(Int32, 'micro_ros_sree_subscriber', 10)
        self.serial_port = serial.Serial('/dev/ttyACM1', 9600, timeout=2)
        
        # Initialize distance storage for all angles
        self.dist_angle_0 = 0    # Right
        self.dist_angle_90 = 0   # Front
        self.dist_angle_180 = 0  # Left
        
        timer_period = 0.1  # seconds
        self.timer = self.create_timer(timer_period, self.timer_callback)
        
        self.get_logger().info('Wall follower node started')

    def timer_callback(self):
        if self.serial_port.in_waiting > 0:
            try:
                data_line = self.serial_port.readline().decode('ascii').strip()
                parts = data_line.split(',')
                
                if len(parts) == 2:
                    current_distance = float(parts[0])
                    current_angle = int(parts[1])
                    
                    # Store distance based on angle
                    if current_angle == 0:
                        self.dist_angle_0 = current_distance
                    elif current_angle == 90:
                        self.dist_angle_90 = current_distance
                    elif current_angle == 180:
                        self.dist_angle_180 = current_distance
                    
                    # Calculate direction based on stored distances
                    direction = self.calculate_direction()
                    
                    # Publish direction
                    msg = Int32()
                    msg.data = direction
                    self.publisher_.publish(msg)
                    
                    self.get_logger().info(
                        f'Distances - Front: {self.dist_angle_90:.1f}, '
                        f'Right: {self.dist_angle_0:.1f}, '
                        f'Left: {self.dist_angle_180:.1f} | Direction: {direction}'
                    )
                    
            except Exception as e:
                self.get_logger().error(f'Error processing serial data: {e}')
    
    def calculate_direction(self):
        """
        Direction codes:
        0 = Stop (all sides blocked or no valid reading)
        1 = Forward (front is clear)
        2 = Right (front blocked, right is clear)
        3 = Left (front blocked, left is clear)
        """
        WALL_THRESHOLD = 30  # cm
        
        # Check if we have valid readings
        if self.dist_angle_90 == 0 and self.dist_angle_0 == 0 and self.dist_angle_180 == 0:
            return 0  # No valid readings, stop
        
        # Priority: Go forward if possible
        if self.dist_angle_90 > WALL_THRESHOLD:
            return 1  # Forward
        
        # Front is blocked, check sides
        if self.dist_angle_0 > WALL_THRESHOLD:
            return 2  # Turn right
        
        if self.dist_angle_180 > WALL_THRESHOLD:
            return 3  # Turn left
        
        # All sides blocked
        return 0  # Stop

def main(args=None):
    rclpy.init(args=args)
    follower_node = wall_follower_node()
    
    try:
        rclpy.spin(follower_node)
    except KeyboardInterrupt:
        pass
    finally:
        follower_node.destroy_node()
        rclpy.shutdown()

if __name__ == '__main__':
    main()
